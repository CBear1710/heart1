<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>GSAP + Three.js Particle Heart</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  canvas{display:block}
  .hud{position:fixed;left:12px;top:10px;color:#9ab;font:14px/1.3 system-ui,Segoe UI,Roboto,Arial,sans-serif;opacity:.85}
</style>
</head>
<body>
<div class="hud">drag to orbit • click/hold to explore • auto-collect animation</div>

<script type="module">
  import * as THREE from 'https://esm.sh/three@0.158.0';
  import { OrbitControls } from 'https://esm.sh/three@0.158.0/examples/jsm/controls/OrbitControls.js';
  import gsap from 'https://esm.sh/gsap@3.12.5';

  /* -------- scene / camera / renderer -------- */
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 5000);
  camera.position.z = 500;

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(devicePixelRatio > 1 ? 2 : 1);
  renderer.setSize(innerWidth, innerHeight);
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.autoRotate = true;         // auto spin
  controls.autoRotateSpeed = 0.7;

  /* -------- build heart points (no SVG needed) -------- */
  // parametric heart curve (classic)
  function heart2D(t) {
    const x = 16 * Math.pow(Math.sin(t), 3);
    const y = 13*Math.cos(t) - 5*Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
    return { x, y };
  }

  // sample many points around the heart silhouette
  const SAMPLES = 3000;                // number of particles
  const scale = 16;                    // base scale -> tune size
  const jitterXY = 30, jitterZ = 70;   // thickness/volume
  const vertices = [];

  for (let i = 0; i < SAMPLES; i++) {
    const t = (i / SAMPLES) * Math.PI * 2;
    const p = heart2D(t);
    // target in 3D with some jitter
    const target = new THREE.Vector3(
      p.x * scale + (Math.random()-0.5) * jitterXY,
      -p.y * scale + (Math.random()-0.5) * jitterXY,
      (Math.random()-0.5) * jitterZ
    );
    vertices.push(target);
  }

  // create geometry/material/points
  const geometry = new THREE.BufferGeometry().setFromPoints(vertices);
  const material = new THREE.PointsMaterial({
    color: 0xee5282,
    size: 3,
    blending: THREE.AdditiveBlending,
    transparent: true,
    depthWrite: false
  });
  const particles = new THREE.Points(geometry, material);
  particles.scale.y = -1;
  scene.add(particles);

  /* -------- GSAP “collect” animation -------- */
  const tl = gsap.timeline({ repeat: -1, yoyo: true });
  // tween each vertex from the center to its target, with a small stagger
  for (let i = 0; i < vertices.length; i++) {
    const v = vertices[i];
    // animate FROM origin to the target (v is mutated by gsap)
    tl.from(v, {
      x: 0, y: 0, z: 0,
      ease: 'power2.inOut',
      duration: gsap.utils.random(2, 5)
    }, i * 0.002); // stagger based on index (like path distance)
  }

  // gentle scene rocking (optional)
  gsap.fromTo(scene.rotation, { y: -0.2 }, {
    y: 0.2,
    repeat: -1,
    yoyo: true,
    ease: 'power2.inOut',
    duration: 3
  });

  /* -------- render loop -------- */
  function render() {
    requestAnimationFrame(render);
    // update geometry with new (tweened) vertex positions
    geometry.setFromPoints(vertices);
    controls.update();
    renderer.render(scene, camera);
  }
  render();

  /* -------- resize -------- */
  addEventListener('resize', () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });
</script>
</body>
</html>
